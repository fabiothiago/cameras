
import requests
from bs4 import BeautifulSoup
import pandas as pd
import logging

# Configura√ß√£o do logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Constantes
COTA_TRANSBORDAMENTO = 2.88  # Cota de transbordamento do rio
FATOR_SENSIBILIDADE = 0.02   # Aumento estimado do n√≠vel por mm de chuva
CHAVE_API_WEATHER = "46506638d20f47c486705852241712"  # Chave da WeatherAPI
CIDADE = "Paracambi"  # Nome da cidade
URL_WEATHERAPI = f"http://api.weatherapi.com/v1/forecast.json?key={CHAVE_API_WEATHER}&q={CIDADE}&days=3&aqi=no&alerts=no"
URL_RIO = "http://alertadecheias.inea.rj.gov.br/alertadecheias/224333320.html"

def extrair_dados_nivel_rio(url):
    """Extrai os dados do n√≠vel do rio da p√°gina HTML."""
    try:
        response = requests.get(url)
        response.raise_for_status()
        soup = BeautifulSoup(response.content, 'html.parser')

        table = soup.find('table', {'id': 'Table'})
        data = []
        for row in table.find_all('tr'):
            cols = row.find_all('td')
            cols = [ele.text.strip() for ele in cols]
            if len(cols) >= 2:  # Garante que tenha ao menos duas colunas
                data.append([cols[0], cols[-1]])  # Pega Data e Hora e N√≠vel do Rio

        df = pd.DataFrame(data[1:], columns=['Data e Hora', 'N√≠vel do rio (m)'])
        df['N√≠vel do rio (m)'] = pd.to_numeric(df['N√≠vel do rio (m)'], errors='coerce')

        return df
    except Exception as e:
        logging.error(f"Erro ao extrair dados do n√≠vel do rio: {e}")
        return None

def obter_previsao_weatherapi():
    """Obt√©m a previs√£o do tempo detalhada para os pr√≥ximos 3 dias usando WeatherAPI."""
    try:
        response = requests.get(URL_WEATHERAPI)
        response.raise_for_status()
        dados = response.json()

        previsao = [
            {
                "data": dia['date'],
                "temp_max": dia['day']['maxtemp_c'],
                "temp_min": dia['day']['mintemp_c'],
                "chuva_mm": dia['day']['totalprecip_mm'],
                "condicao": dia['day']['condition']['text']
            }
            for dia in dados['forecast']['forecastday']
        ]
        return previsao
    except Exception as e:
        logging.error(f"Erro ao obter previs√£o do tempo: {e}")
        return None

def gerar_previsao_nivel_rio(nivel_atual, previsao_chuva):
    """Gera uma previs√£o do n√≠vel do rio com base na precipita√ß√£o prevista."""
    previsao = []
    for dia in previsao_chuva:
        aumento_estimado = dia['chuva_mm'] * FATOR_SENSIBILIDADE
        nivel_previsto = round(nivel_atual + aumento_estimado, 2)
        risco = classificar_risco(nivel_previsto)
        previsao.append({
            "data": dia['data'],
            "chuva_mm": dia['chuva_mm'],
            "nivel_previsto": nivel_previsto,
            "temp_max": dia['temp_max'],
            "temp_min": dia['temp_min'],
            "condicao": dia['condicao'],
            "risco": risco
        })
    return previsao

def classificar_risco(nivel):
    """Classifica o risco baseado no n√≠vel previsto do rio."""
    if nivel >= COTA_TRANSBORDAMENTO:
        return "‚ö†Ô∏è Risco Cr√≠tico - Transbordamento iminente!"
    elif nivel >= COTA_TRANSBORDAMENTO * 0.7:
        return "‚ö†Ô∏è Risco Alto - N√≠vel pr√≥ximo ao limite."
    else:
        return "‚úÖ Risco Baixo - Condi√ß√µes est√°veis."

def gerar_relatorio(nivel_atual, previsao_rio):
    """Gera um relat√≥rio consolidado do estado atual e previs√£o do n√≠vel do rio."""
    relatorio = (f"\nüîπ **Relat√≥rio do Rio dos Macacos** üîπ\n"
                 f"N√≠vel atual: {nivel_atual:.2f} m\n"
                 f"Cota de transbordamento: {COTA_TRANSBORDAMENTO:.2f} m\n\n")

    for dia in previsao_rio:
        relatorio += (f"üìÖ **Previs√£o para {dia['data']}**:\n"
                      f"Condi√ß√£o: {dia['condicao']}\n"
                      f"Temperatura: {dia['temp_min']}¬∞C - {dia['temp_max']}¬∞C\n"
                      f"Precipita√ß√£o prevista: {dia['chuva_mm']} mm\n"
                      f"N√≠vel previsto do rio: {dia['nivel_previsto']} m\n"
                      f"Classifica√ß√£o: {dia['risco']}\n\n")

    return relatorio

if __name__ == "__main__":
    logging.info("Iniciando o monitoramento do n√≠vel do rio e previs√£o do tempo.")
    
    # Extra√ß√£o do n√≠vel do rio
    df_nivel_rio = extrair_dados_nivel_rio(URL_RIO)
    if df_nivel_rio is not None and not df_nivel_rio.empty:
        nivel_atual = df_nivel_rio['N√≠vel do rio (m)'].iloc[-1]
        logging.info(f"N√≠vel atual do rio: {nivel_atual:.2f} m.")

        # Obten√ß√£o da previs√£o do tempo
        previsao_tempo = obter_previsao_weatherapi()
        if previsao_tempo:
            # C√°lculo da previs√£o do n√≠vel do rio
            previsao_nivel_rio = gerar_previsao_nivel_rio(nivel_atual, previsao_tempo)
            if previsao_nivel_rio:
                # Gera√ß√£o do relat√≥rio consolidado
                relatorio = gerar_relatorio(nivel_atual, previsao_nivel_rio)
                print(relatorio)
            else:
                logging.error("Erro ao calcular a previs√£o do n√≠vel do rio.")
        else:
            logging.error("Erro ao obter a previs√£o do tempo.")
    else:
        logging.error("Erro ao carregar os dados do n√≠vel do rio.")
